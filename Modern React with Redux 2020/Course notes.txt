***********************************************Section 2 Building content with JSX***************************************
What is JSX?
Babel converts our normal html code that we write in React component(using JSX) to ES5 format or Javascript format which every browser understands.

See image - Babel-diagram.png

Visit Babeljs.io to see how babel converts jsx to javascript.
 See images - Babel-conversion1.png and Babel-conversion2.png
 
--------------------------------Difference between HTML and JSX code syntax-----------

We have 3 differences - Html-JSX-all-differences.png

-----Difference 1 - css styling syntax difference between HTML and JSX.

Go to codepen.io and type below code:
<div>
  <label class="label" for="name"> Enter name:</label>
  <input id="name" type="text"/>
  <button style="background-color:blue; color: white;">Submit</button>
</div>

See diagram - codepen-code.png

Create new react project for handson
command to create new project is - 
D:\JPMC-Data\Udemy trainings\Modern React with Redux 2020\workspace>npx create-react-app html-jsx-syntax-difference

Delete src contents and add contents as shown in project.

Now type same code in react component(App.js) and see if it works.
Error found - HTML-code-error.png

Syntax difference: 
<button style="background-color:blue; color: white;">Submit</button> 
has been changed to 
<button style={{backgroundColor:'blue', color: 'white'}}>Submit</button>
First curly brace indicates javascript variable and second one indicates javascript object.

----Difference 2 - Adding a class to element using different syntax

<label class="label" for="name"> Enter name:</label>
in JSX is
<label class="label" for="name"> Enter name:</label>

class is called className to differentiate between class component keyword.
It stills allows class as well as some flexibility and may be removed in future.

-----Difference 3: JSX can reference JS variables

See - Difference 3 component

-------------------How to fix html and jsx differences warning on our own--

Inspect Difference1 component and see that 'for' is 'htmlFor' in JSX. Just replace it with 'htmlFor' and test it.
See - console-inspect.png


************************************************Section 3 Communicating with Props*******************************************

3 topics in scope - Topics-in-scope.png
Mockup for this section - Mockup.png

Semantic UI CDN link - <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.4.1/semantic.min.css">

Practicals - 
D:\JPMC-Data\Udemy trainings\Modern React with Redux 2020\workspace>npx create-react-app section-3-components

Remove all files from src and create App component in index.js

Next to integrate semantic ui in our project.
search for semantic cdn in google and open first link i.e. https://cdnjs.com/libraries/semantic-ui
Once open, click on css tab and scroll down or search for semantic.min.css and copy the url and paste it in index.html of our project.

To confirm that semantic css has been loaded. Observe the hello world text in div of App component will change it's font.
Another way to confirm is go to inspect and select network and click on css option. Reload page and see semantic css has been loaded.

See - Before-adding-sematic-cdn.png and after-adding-sematic-cdn.png

Faker JS is used to create fake image, company, finance data or avatar.
Visit faker.js github to see the documentation.
-https://github.com/marak/Faker.js/

To add faker to our project, execute below command
npm install --save faker


********************************Section 4 Sturcturing Apps with class based components***********************************
Difference-betn-class-and-function-component.png

Earlier function component was only used to show JSX content and not play with lifecycle/state objects.
With newer version of react, functional components can also play with lifecycle and state. This is achieved with the help of hooks.
See - functional-component-with-hooks.png

When to use class and functional components in our project?
See - when-to-use-class-or-functional-components.png

Benefits-of-class-component.png

Application-mockup.png

App-challenges.png

GeoLocation API link mentioned below has documentation on how to fetch geolocation using position object.
https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API
Note: it is unavailable in china.

To see geolocation in code, go to console and observe
See -> my-geolocation.png

Once user says to allows to geolocation pop up, it will be always allowed.
To reset and ask again, click on the 'i' icon and say 'ask'.
See - how-to-reset-geolocation-preferences.png

******************************************Section 5 - State in React components***************
Rules_of_state.png

App-lifecycle.png

How to run this source code:
==========================
Positive scenario image1: Positive-scenario-image1.png
Positive scenario image2: Positive-scenario-image2.png
Positive scenario image3: Positive-scenario-image3.png

Negative scenario image1: Negative-scenario-image1.png 
Negative scenario image2: Negative-scenario-image2.png
Negative scenario image3: Negative-scenario-image3.png

******************************************Section 6 - Understanding Lifecycle methods*************

Lifecycle stages - Lifecycle-methods.png

Render method is used to only return JSX code and not do anything else.
ComponentDidMount gets invoked only once. It is best place to do data loading or location fetching.
Though constructor & ComponentDidMount both are best places to do component data loading kind of stuff, but it is advisable to do it in ComponentDidMount as per REACT docs/standards.

ComponentDidUpdate should be used when we want to do data reloading everytime there is change in state/props.

ComponentWillUnmount will be used mainly for some kind of cleanup.

See - Lifecycle-methods-with-desc.png

See - Rarely-used-lifecycle-methods.png

shouldComponentUpdate()
=======================

shouldComponentUpdate(nextProps, nextState)
Use shouldComponentUpdate() to let React know if a component’s output is not affected by the current change in state or props. The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior.

shouldComponentUpdate() is invoked before rendering when new props or state are being received. Defaults to true. This method is not called for the initial render or when forceUpdate() is used.

This method only exists as a performance optimization. Do not rely on it to “prevent” a rendering, as this can lead to bugs. Consider using the built-in PureComponent instead of writing shouldComponentUpdate() by hand. PureComponent performs a shallow comparison of props and state, and reduces the chance that you’ll skip a necessary update.

If you are confident you want to write it by hand, you may compare this.props with nextProps and this.state with nextState and return false to tell React the update can be skipped. Note that returning false does not prevent child components from re-rendering when their state changes.

We do not recommend doing deep equality checks or using JSON.stringify() in shouldComponentUpdate(). It is very inefficient and will harm performance.

Currently, if shouldComponentUpdate() returns false, then UNSAFE_componentWillUpdate(), render(), and componentDidUpdate() will not be invoked. In the future React may treat shouldComponentUpdate() as a hint rather than a strict directive, and returning false may still result in a re-rendering of the component.

static getDerivedStateFromProps()
================================

static getDerivedStateFromProps(props, state)
getDerivedStateFromProps is invoked right before calling the render method, both on the initial mount and on subsequent updates. It should return an object to update the state, or null to update nothing.

This method exists for rare use cases where the state depends on changes in props over time. For example, it might be handy for implementing a <Transition> component that compares its previous and next children to decide which of them to animate in and out.

Deriving state leads to verbose code and makes your components difficult to think about.
Make sure you’re familiar with simpler alternatives:

If you need to perform a side effect (for example, data fetching or an animation) in response to a change in props, use componentDidUpdate lifecycle instead.
If you want to re-compute some data only when a prop changes, use a memoization helper instead.
If you want to “reset” some state when a prop changes, consider either making a component fully controlled or fully uncontrolled with a key instead.
This method doesn’t have access to the component instance. If you’d like, you can reuse some code between getDerivedStateFromProps() and the other class methods by extracting pure functions of the component props and state outside the class definition.

Note that this method is fired on every render, regardless of the cause. This is in contrast to UNSAFE_componentWillReceiveProps, which only fires when the parent causes a re-render and not as a result of a local setState.

getSnapshotBeforeUpdate()
========================

getSnapshotBeforeUpdate(prevProps, prevState)
getSnapshotBeforeUpdate() is invoked right before the most recently rendered output is committed to e.g. the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle will be passed as a parameter to componentDidUpdate().

This use case is not common, but it may occur in UIs like a chat thread that need to handle scroll position in a special way.

A snapshot value (or null) should be returned.

----------------------------------------------------------------

constructor(props){
            super(props);
            this.state = {
                lat: null,
                errorMessage: ''
            }
        }

can be written as 
state = {lat: null, errorMessage: ''}

because babel on it's own convert this line to constructor.
to confirm, visit babeljs.io, click on try it out and enable stage1, stage2, stage3, react.
Paste the code on LHS and see the converted version on RHS.

See - Babel-convertor-with-constructor.png


See - Northern-Southern-hemisphere-weather-identify-chart.png
Note: in above image, orange indicates summer and blue indicates winter.
Note: 0 to 11 are months. with 0 being Jan and 11 being Dec.

See - Benefits-of-class-based-components.png

See - Rules-of-class-components.png

See - Project-output-1.png
See - Project-output-2.png

******************************************Section 7 - Handling user input with forms and events*************

See - App-mock-up.png
See - App-mock-up-v2.png
See - App-challenges.png
See - Components-diagram.png

onSubmit this->this
Cannot read property 'state' of undefined.

Solution1:
Another way of solving above issue is to use bind in constructor.
See - Fix-context-issues.png


Solution2: 
Use arrow function, this arrow function always consider this as class object. In  this case it is searchBar object.
See - Using-arrow-function.png

Solution3: 
Use arrow function while invoking onSubmit event.
See - Using-arrow-function-onsubmitEvent.png

See - Communicating-child-to-parent.png


******************************************Section 8 - Making API requests with React*************

See - Mockup-for-using-unplash-API.png

-------All about unsplash begin----------------

Unsplash is a company that provide API to return whatever we ask for, eg. If we ask for cars, it will send back list of car images matching our search criteria.

Creating account and appplication in unsplash
launch : https://unsplash.com/developers
Click on register as developer.
Join using facebook was not working, so create a new account.

Click on New Application 
Application Name: React Pics
Desc: This application is used to fetch pics

TO get root URI for unsplash, go to documentation.
click on schema -> location.

to know how to pass authorization header to unsplash.
Clik on documentation , Authorization.

To get access key 
Go to unsplash application that we had created, scroll down and pick the access key.

How to get specific car url that we want to use in our application.
Once made axios call to unspalsh, go to console->inspect->Network.
Clik on Get cars call, click on preview, Scroll down to see urls, select regular one and copy the URL.

Now click on documentation tab and click on search photos and understand on how to fetch images.




See - React-to-unspalsh-communication.png

-------All about unsplash end----------------

See - axios-vs-fetch.png

Always use axios when compared to fetch because if we use fetch we have to access very low level functions.
It also has corner case issues. axios has all inbuilt and easy to use.

npm install --save axios

import standards:
always put third party imports above user defined imports.

See - Application-flow.png

---------------------------------Asynchronous handling concept---------------

  onSearchSubmit(term) {
        axios.get(url, params, headers);		
  };
  
In above snipper, axios.get is an asynchronous call, so the function flow will go ahead and get will happen separately.
To handle this, we can call 'then' on promise.

axios.get() returns a promise.We can add '.then' on promise to make this call synchronous and fetch the data after it completes.

So new code is 

  onSearchSubmit(term) {
        axios.get(url, params, headers).then(respone => {console.log(response)});		
  };

-----
Another way of solving above problem.

  async onSearchSubmit(term) {
        const response = await axios.get(url, params, headers);
		console.log(response);
  };
  
Aysnc await is a lot simpler to understand when compared with '.then' promise.


**************************************Section 9 Building list of records*********************************

See - For_Loop_verses_Map.png

We can improve performance in react by loading only that particular element in a list which has been modified.
We can do this by adding id attribute to the list, which should be unique for every element in the list.

See - Performance-improve-by-ID.png
See in above diagram only key=4 would be added from new rendered list to currently in the DOM object.

It won't rerender entire component in this case.

Note: Section 9 code is available in section-8 project in workspace folder.
This completes v1 implementation.

**************************************Section 10 Using Ref for DOM access*********************************

See - Steps-to-adjust-image-size.png

See - how-to-use-react-ref.png

This is V2 implementation.


**************************************Section 12 Understanding hooks in React*********************************
													*********
													*Theory:*
													*********

See - Learning-pattern.png

Features-of-hooks.png

All-primitive-hooks.png

useContext
==========
const value = useContext(MyContext);
Accepts a context object (the value returned from React.createContext) and returns the current context value for that context. The current context value is determined by the value prop of the nearest <MyContext.Provider> above the calling component in the tree.

When the nearest <MyContext.Provider> above the component updates, this Hook will trigger a rerender with the latest context value passed to that MyContext provider. Even if an ancestor uses React.memo or shouldComponentUpdate, a rerender will still happen starting at the component itself using useContext.


useReducer
=========
const [state, dispatch] = useReducer(reducer, initialArg, init);
An alternative to useState. Accepts a reducer of type (state, action) => newState, and returns the current state paired with a dispatch method. (If you’re familiar with Redux, you already know how this works.)

useReducer is usually preferable to useState when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. useReducer also lets you optimize performance for components that trigger deep updates because you can pass dispatch down instead of callbacks.


useCallback
===========
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);
Returns a memoized callback.

Pass an inline callback and an array of dependencies. useCallback will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. shouldComponentUpdate).


useMemo
=======
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
Returns a memoized value.

Pass a “create” function and an array of dependencies. useMemo will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.

Remember that the function passed to useMemo runs during rendering. Don’t do anything there that you wouldn’t normally do while rendering. For example, side effects belong in useEffect, not useMemo.


useLayoutEffect
===============
The signature is identical to useEffect, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.

Prefer the standard useEffect when possible to avoid blocking visual updates.

useDebugValue
=============
useDebugValue(value)
useDebugValue can be used to display a label for custom hooks in React DevTools.

For example, consider the useFriendStatus custom Hook described in “Building Your Own Hooks”:

----------------------------------------------------------------------------------------------------

Custom-hook.png


													************
													*Practicals*
													************

---------------------------------------Application 1 Accordion begin----------------------------------


App-mockup.png

App-design.png

design-to-make-sure-only-one-question-to-show-at-a-time.png

What does accordion style mean?
The accordion is a graphical control element comprising a vertically stacked list of items, such as labels or thumbnails. ... An accordion is similar in purpose to a tabbed interface, a list of items where exactly one item is expanded into a panel (i.e. list items are shortcuts to access separate panels).

Array-destructuring-eg.png
How-useState-works.png
state-setting-diff-betn-class-func-components.png

multi-state-setting-diff-betn-class-func-components.png

---------------------------------------Application 1 Accordion end----------------------------------


---------------------------------------Application 2 Counter begin----------------------------------
Counter-example-mockup.png

Counter-example-solution.PNG

---------------------------------------Application 2 Counter begin----------------------------------

---------------------------------------Application 3 List begin----------------------------------

List-mockup.png

Wikipedia-API-for-searching.png

App-design-for-search.png

2-possible-options-of-doing-search.png

Why-search-option2-is-better-than-1.png
Note: option2 is better because we can trigger search even if any other part of component changes and not necessarily onChange event like option1. This can be achieved using useEffect.

The-use-effect-hook.png

useEffect-second-argument-options.png

npm install axios

Note: Arrow function defined within useEffect cannot be of type async and await.
Solution1: We can have body withing arrow function of useEffect to be of type async function.
See - Solution1.png

Solution2: wrap the function in braces and add another parameter as a brace.
See - Solution2.png

Solution3: Use the 'then' method of promise.
See - Solution3.PNG

React recommends solution1.

Code notes:
Because wikipedia returned results with some <span> in it, we can directly render that html in react using dangerouslySetInnerHTML as shown in below pic.
It leads to XSS(Cross site scripting) attacks, as some third party html we are rendering in our application.
See - dangerouslySetInnerHTML.png

See - throttle-api-requests.png
See - throttle-api-requests-detailed-dgm.PNG

See - Steps-to-clear-setTimeOut.png
As shown in diagram, everytime we call setTimeOut, it returns a unique number and clearing that unique number, resets the timer to 0.

See - How-is-cleanup-called-in-useeffect.png
The only thing that useEffect function can return is another arrow function output in return statement.
First time when component gets rendered useEffect gets called and than return cleanup will be kept on hold.
Only on any state change like term change, the cleanup of previous call will be called first and then new useEffect will be called.

---------------------------------------Application 3 List end----------------------------------

---------------------------------------Application 4 Dropdown begin----------------------------------

Dropdown-mockup.png

See - Event-bubbling-concept.png
How it works?
For any event it could be onClickEvent, the browser first gets the event and then forwards it to React App.
One more thing to notice is for every event it travels all the way to parent to see if someone has handled the event else invokes onClickEvent handler of the current component. That is event bubbling all the way up till html.

See - When-to-use-event-bubbling.png

See - How-to-implement-event-bubbling.png

See - How-to-set-event-listener-on-body.png

See - Order-of-events-getting-called-using-event-bubbling1.png
See - Order-of-events-getting-called-using-event-bubbling2.PNG
Please note that first addEventListener takes preference and then react listeners comes into play.

See - Scenario1-to-consider-while-closing-dropdown.png
See - Scenario2-to-consider-while-closing-dropdown.PNG
Problem: When we click on dropdown element, body event listener was closing the dropdown, but when onclick event listener of dropdown event listener was called it was setting !open, so dropdown was opening again.
Solution to close the dropdown on click on dropdown element or body is to stop body event listener from closing the dropdown if we click on dropdown element.
This can be achieved by using useRef, add ref to most parent element of dropdown element and then check if the onClick event is matching with the ref. If it matches then don't let body event listener close the dropdown.

---------------------------------------Application 4 Dropdown end----------------------------------

---------------------------------------Application 5 Translate begin----------------------------------

Translate-mockup.png
Translate-component-design.PNG
Convert-component-design.png
Google-translate-API.png

To see google translate docs.
search in google for 'google translate API'.

Click on API and reference in from https://cloud.google.com/translate/docs

Click on translate link as shown in Google-translate-API-docs.PNG

To know languages supported, click on language support link as shown in Google-translate-API-language-support.PNG


Free google translate API key:
============================

Google Translate API Key
This is the API key you should use for the Google Translate API. Copy paste this into the top of your ‘Translate.js’ file for right now. Of course, make sure you comment it out.

AIzaSyCHUCmpR7cT_yDFHC98CZJy2LTms-IwDlM

This API can only be used when your browser is at ‘http://localhost:3000’. If you try to make a request to the API from any other address, the request will fail.

npm install axios --save

---------------------------------------Application 5 Translate end----------------------------------


*********************************************Section13 - Navigation from scratch********************

About-React-Router.png

Open console and type window.location to see the pathname before implementing router.
See - Deriving-pathname.png

Route-mappings.png

Adding-navigation-event.png

*********************************************Section 14 - Hooks in practice**************************

This is youtube videos application.
See - Application-mockup.png
Custom-hooks.png

Rules-for-custom-hooks.png
Custom hooks are not used to make JSX code reusbale (for this we can define reusable component), but custom hooks are used to make state setting and retrieving reusable.

Process-for-creating-custom-reusable-hooks.png


*********************************************Section 16 - On we go to Redux**************************

See - Es15-syntax-3-dots.png
See - Source code for code pen.txt

Refer  - Redux-diagrams.xml
Open this using draw.io to view all the images used in this section.


*********************************************Section 17 - Integrating react with redux**************************

npm install --save redux react-redux

Add semantic ui cdn

Provider and connect libraries are provided by react-redux. 
Provider just makes sure that all the redux store data is provided to all the components.
connect connects to reducers/store data via provider.

When we have named export like export const fucntioName{}
We should import it using {}
Similarly when we have default export like export default functionName
We should import it without {}

See - how-connect-works.png
connect() ()
the second set of paranthesis says that invoke the returning function.

All this section images are present in Integrating-react-with-redux-diagrams.xml


*********************************************Section 18 TBD**************************


